     1                                  ; 加电启动后，一旦BIOS发现了一个正确的引导扇区(以0xAA55结尾)，它就会将这个引导扇区的512B的内容加载到内存0x7c00处，这是由硬件决定的。
     2                                  ; 然后就跳转到内存0000:0x7c00处开始执行其上的指令。
     3                                  
     4                                  ; 值得注意的时，即使没有这个org汇编伪指令，往后的这些内容都将会被加载到内存0000:0x7c00处
     5                                  ; 汇编伪指令，表示往后需要计算 label 的绝对地址时，还再要加上0x7c00的偏移量。
     6                                  ; 如果不涉及 label的计算，那么是不需要这个指令的
     7                                  org 0x7c00
     8                                  
     9                                  
    10                                  ; ======================================================================================================================
    11                                  ; 一些宏定义
    12                                  ; ----------------------------------------------------------------------------------------------------------------------
    13                                  StackBase equ 0x7c00    ; 用0x7c00以下的地方来作为栈，要注意不要溢出
    14                                  MessageLength		equ	10  ; 为简化代码, 下面每个字符串的长度均为 MessageLength
    15                                  ; ======================================================================================================================
    16                                  
    17                                  
    18 00000000 E90100                      jmp BEGIN   ; 直接跳转指令
    19 00000003 90                          nop ; 空指令
    20                                      ; 引导扇区的格式之一
    21                                  
    22                                  
    23                                  ; ======================================================================================================================
    24                                  ; 引导程序
    25                                  ; ----------------------------------------------------------------------------------------------------------------------
    26                                  BEGIN:
    27                                      ; 寄存器复位
    28 00000004 8CC8                        mov ax, cs
    29 00000006 8ED8                        mov ds, ax
    30 00000008 8ED0                        mov ss, ax
    31                                      ; 此时代码段、数据段、堆栈段地址都是一样的
    32 0000000A BC007C                      mov sp, StackBase   ; sp指向当前栈顶，栈向低地址生长
    33                                  
    34                                      ; 清理屏幕
    35 0000000D E80700                      call CLEAR  ; 相当于将ip压栈，然后改变ip。
    36                                  
    37                                      ; 显示字符串 "Booting..."
    38 00000010 B600                        mov	dh, 0			; "Booting..."
    39 00000012 E84300                      call STRING_PRINT		; 显示字符串
    40                                  
    41                                      ; $为汇编伪指令，表示当前地址
    42 00000015 EBFE                        jmp $   ; 进入死循环，防止运行到奇怪的代码
    43                                  ; ======================================================================================================================
    44                                  
    45                                  
    46                                  ; ======================================================================================================================
    47                                  ; 清屏函数，清理BIOS的输出，通过call来调用，不可以用jmp
    48                                  ; ----------------------------------------------------------------------------------------------------------------------
    49                                  CLEAR:
    50                                      ; ax bx cx dx 压栈
    51 00000017 50                          push ax
    52 00000018 53                          push bx
    53 00000019 51                          push cx
    54 0000001A 52                          push dx
    55                                  
    56                                      ; 调用10号中断，清理输出
    57 0000001B B80006                      mov	ax, 0x0600  ; AH = 6,  AL = 0h
    58 0000001E BB0007                      mov	bx, 0x0700  ; 黑底白字(BL = 07h)
    59 00000021 B90000                      mov	cx, 0   ; 左上角: (0, 0)
    60 00000024 BA4F18                      mov	dx, 0x0184f ; 右下角: (80, 50)
    61 00000027 CD10                        int	0x10
    62                                  
    63                                      ; 恢复 dx cx bx ax
    64 00000029 5A                          pop dx
    65 0000002A 59                          pop cx
    66 0000002B 5B                          pop bx
    67 0000002C 58                          pop ax
    68                                  
    69                                      ; 相当于恢复之前压栈的ip，返回原来的地方，接着执行原来的下一条指令
    70 0000002D C3                          ret
    71                                  ; ======================================================================================================================
    72                                  
    73                                  
    74                                  ;=======================================================================================================================
    75                                  ; 要显示的字符串
    76                                  ; db 汇编伪指令，表示其后的每个操作数占1字节。dw，2字节。dd，double word 4字节。
    77                                  ;-----------------------------------------------------------------------------------------------------------------------
    78 0000002E 4C4F41444552202042-     LoaderFileName		db	"LOADER  BIN", 0    ; LOADER.BIN 之文件名
    79 00000037 494E00             
    80                                  
    81                                  ; 启动时的一些信息
    82 0000003A 426F6F74696E672E2E-     BootMessage:		db	"Booting..."    ; 12字节, 不够则用空格补齐. 序号 0
    83 00000043 2E                 
    84 00000044 4C6F61646564205E2D-                         db  "Loaded ^-^"
    85 0000004D 5E                 
    86 0000004E 4E4F204C4F41444552-                         db  "NO LOADER!"
    87 00000057 21                 
    88                                  ;=======================================================================================================================
    89                                  
    90                                  
    91                                  ;=======================================================================================================================
    92                                  ; 字符串显示函数
    93                                  ; 显示一个字符串, 函数开始时 dh 中应该是字符串序号(0-based)，即 dh=0 -> "Booting..." dh=1 -> "Loaded ^-^"，且dh为要打印的行
    94                                  ;-----------------------------------------------------------------------------------------------------------------------
    95                                  STRING_PRINT:
    96 00000058 50                          push ax
    97 00000059 55                          push bp
    98 0000005A 1E                          push ds
    99 0000005B 06                          push es
   100 0000005C 51                          push cx
   101 0000005D 53                          push bx
   102 0000005E 52                          push dx
   103                                  
   104 0000005F B80A00                  	mov	ax, MessageLength
   105 00000062 F6E6                    	mul	dh
   106 00000064 05[3A00]                	add	ax, BootMessage
   107 00000067 89C5                    	mov	bp, ax  ; ┓
   108 00000069 8CD8                    	mov	ax, ds  ; ┣ ES:BP = 串地址
   109 0000006B 8EC0                    	mov	es, ax  ; ┛
   110                                  	; es = ds, 但由于两个段寄存器间没有直接通路，所以不能使用mov指令，也就是说mov指令的两个操作数不能同时为段寄存器
   111                                      ; 所以要借助第三方中转，比如可以  mov ax,ds   mov es,ax
   112                                  
   113 0000006D B90A00                  	mov	cx, MessageLength   ; CX = 串长度
   114 00000070 B80113                  	mov	ax, 1301h   ; AH = 13,  AL = 01h
   115 00000073 BB0700                  	mov	bx, 0007h   ; 页号为0(BH = 0) 黑底白字(BL = 07h)
   116 00000076 B200                    	mov	dl, 0   ; 要打印的位置 列
   117 00000078 CD10                    	int	10h
   118                                  
   119 0000007A 5A                      	pop dx
   120 0000007B 5B                      	pop bx
   121 0000007C 59                      	pop cx
   122 0000007D 07                      	pop es
   123 0000007E 1F                      	pop ds
   124 0000007F 5D                      	pop bp
   125 00000080 58                      	pop ax
   126 00000081 C3                      	ret
   127                                  ;=======================================================================================================================
   128                                  
   129                                  
   130                                  ; $$为汇编伪指令，表示起始地址
   131 00000082 00<rept>                times 510-($-$$) db 0   ; 意思是从当前到510，用0来填充
   132                                  
   133 000001FE 55AA                    dw 0xaa55   ; 引导扇区的结束标记
