; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   计算内存大小
; 本函数根据之前保存的ARDS，计算内存总大小并保存起来
; ----------------------------------------------------------------------------------------------------------------------
cal_mem_size:
    push esi
    push ecx
    push edx
    push edi

    mov esi, MEM_CHK_BUF_32         ; ds:esi -> 缓冲区
    mov ecx, [MCR_COUNT_DD_32]      ; ecx = 有多少个ARDS，记为i
.loop:
    mov edx, 5                      ; ARDS有5个成员变量，记为j
    mov edi, ARDS_32                ; ds:edi -> 一个ARDS结构
.1: ; 将缓冲区中的第 i 个ARDS结构拷贝到ds:edi中的ARDS结构
    push dword [esi]
    pop eax                         ; ds:eax -> 缓冲区中的第一个ADRS结构
    stosd                           ; 将ds:eax中的一个dword内容拷贝到ds:edi中，填充ADRS结构
    add esi, 4                      ; ds:esi指向ARDS中的下一个成员变量
    dec edx                         ; j--
    cmp edx, 0
    jnz .1                          ; j != 0，继续填充
    ; j == 0，ARDS结构填充完毕
    cmp dword [TYPE_DD_32], 1
    jne .2                          ; 不是OS可使用的内存范围，直接进入下个外循环看下一个ARDS
    ; 是OS可用的地址范围，我们计算这个ARDS的内存大小
    mov eax, [BASE_ADDR_LOW_DD_32]  ; eax = 基地址低32位
    add eax, [LENGTH_LOW_DD_32]     ; eax = 基地址低32位 + 长度低32位 --> 这个ARDS结构的指代的内存大小
                                    ; 为什么不算高32为？因为32位既可以表示0~4G的内存范围，而32位CPU也只能识别0~4G
                                    ; 我们编写的是32位操作系统，所以高32位是为64位操作系统做准备的，我们不需要。
    cmp eax, [MEM_SIZE_DD_32]
    jb .2
    mov dword [MEM_SIZE_DD_32], eax ; 内存大小 = 最后一个基地址最大的ARDS的  基地址低32位 + 长度低32位
.2:
    loop .loop                      ; jmp .loop, ecx--

    pop edi
    pop edx
    pop ecx
    pop esi
    ret
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   打印内存大小(以KB显示)
; ----------------------------------------------------------------------------------------------------------------------
print_mem_size:
    push ebx
    push ecx

    mov eax, [MEM_SIZE_DD_32]       ; eax = 内存大小
    xor edx, edx
    mov ebx, 1024
    div ebx                         ; eax / 1024 --> 内存大小(字节) / 1024 = 内存大小(KB)

    push eax                        ; 保存计算好的内存大小
    ; 显示一个字符串"Memory Size: "
    push STR_MEM_SIZE_32
    call print
    add esp, 4

    ; 因为之前已经压入eax了，不需要再压入！
    call print_int
    add esp, 4

    ; 打印"KB"
    push STR_KB_32
    call print
    add esp, 4

    pop ecx
    pop ebx
    ret
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   启动分页机制
; 根据内存的大小来计算应初始化多少的PDE以及多少PTE，我们给每页分4K大小
; 注意：页目录表存放在4M(0x400000)~4.4M处(0x401000)
;      所有页表存放在4.4M(0x101000)~9.4M处(0x501000)
; -----------------------------------------------------------------------------------------------------------------------
setup_paging:
    xor edx, edx                    ; edx = 0
    mov eax, [MEM_SIZE_DD_32]       ; eax = 内存大小
    mov ebx, 0x400000               ; 0x400000 = 4M = 4096 * 1024，即一个页表所管理的内存大小
    div ebx                         ; 内存大小 / 4M
    mov ecx, eax                    ; ecx = 需要的页表的个数，即 PDE 个数，理论上不会超过1024个
    test edx, edx
    jz .no_remainder                ; if(edx == 0) jmp .no_remainder，没有余数
    inc ecx                         ; else ecx++，有余数则需要多一个 PDE 去映射它
.no_remainder:
    push ecx                        ; 保存页表个数
    ; 为了简化处理，所有线性地址对应相等的物理地址，并且暂不考虑内存碎片

    ; 首先初始化页目录
    mov ax, DATA_SEG_SELECTOR
    mov es, ax
    mov edi, PAGE_DIR_BASE          ; edi = 页目录存放的首地址
    xor eax, eax
; ----------------------------------------------------------------------------------------------------------------------
; PDE存储页表的地址
; eax = PDE，PG_P（该页存在）、PG_US_U（用户级页）、PG_RW_W（可读、写、执行）
; ----------------------------------------------------------------------------------------------------------------------
    mov eax, PAGE_TABLE_BASE | PG_P | PG_US_U | PG_RW_W
.setup_pde:  ; 设置 PDE
    stosd                           ; 将ds:eax中的一个dword内容拷贝到ds:edi中，填充页目录项结构，同时edi+=4
    add eax, 4096                   ; 所有页表在内存中连续，1个页表也占4KB
    loop .setup_pde                 ; 直到ecx = 0，才退出循环，ecx是需要的页表个数

    ; 现在开始初始化所有页表
    pop eax                         ; 取出页表个数
    mov ebx, 1024                   ; 每个页表可以存放 1024 个 PTE
    mul ebx                         ; 页表个数 * 1024，得到需要多少个PTE
    mov ecx, eax                    ; eax = PTE个数，放在ecx里是因为准备开始循环设置 PTE
    mov edi, PAGE_TABLE_BASE        ; edi = 页表存放的首地址
    xor eax, eax
; ----------------------------------------------------------------------------------------------------------------------
; PTE存储页的地址，页从物理地址 0 开始映射
; eax = PTE
; ----------------------------------------------------------------------------------------------------------------------
    mov eax, 0x0 | PG_P | PG_US_U | PG_RW_W
.setup_pte:  ; 设置 PTE
    stosd                           ; 将ds:eax中的一个dword内容拷贝到ds:edi中，填充页表项结构，同时edi+=4
    add eax, 4096                   ; 每一页指向 4K 的内存空间
    loop .setup_pte                 ; 直到ecx = 0，才退出循环，ecx是需要的PTE个数

    ; 最后设置 cr3 寄存器和 cr0，开启分页机制
    mov eax, PAGE_DIR_BASE
    mov cr3, eax                    ; cr3 -> 页目录表
    mov eax, cr0
    or eax, 0x80000000              ; 将 cr0 中的 PG位（分页机制）置位
    mov cr0, eax
    jmp .setup_pg_ok                ; 和进入保护模式一样，一个跳转指令使其生效
.setup_pg_ok:
     nop                            ; 一个小延迟，给一点时间让CPU反应一下
     nop                            ; 空指令
     push STR_SETUP_PAGING_32
     call print
     add esp, 4
     ret
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   打印函数，它类似与C语言中的printf，但它不支持'%'可变参数
; 函数原型：print(void* ds:ptr)，ptr指向要打印的字符串，字符串以0结尾
; ----------------------------------------------------------------------------------------------------------------------
print:
    push esi
    push edi

    mov esi, [esp + 4 * 3]      ; 得到字符串地址
    mov edi, [DISP_POSITION_DD_32]   ; 得到显示位置
    mov ah, 0xf                 ; 黑底白字
.1:
    lodsb                       ; ds:esi -> al, esi++
    test al, al
    jz .print_end               ; 遇到了0，结束打印
    cmp al, 10
    je .2
    ; 如果不是0，也不是'\n'，那么我们认为它是一个可打印的普通字符
    mov [gs:edi], ax
    add edi, 2                  ; 指向下一列
    jmp .1
.2: ; 处理换行符'\n'
    push eax
    mov eax, edi                ; eax = 显示位置
    mov bl, 160
    div bl                      ; 显示位置 / 320，商eax就是当前所在行数
    inc eax                     ; 行数++
    mov bl, 160
    mul bl                      ; 行数 * 320，得出这行的显示位置
    mov edi, eax                ; edi = 新的显示位置
    pop eax
    jmp .1
.print_end:
    mov dword [DISP_POSITION_DD_32], edi ; 打印完毕，更新显示位置

    pop edi
    pop esi
    ret
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   显示 AL 中的数字
; ----------------------------------------------------------------------------------------------------------------------
print_al:
	push ecx
	push edx
	push edi
	push eax

	mov edi, [DISP_POSITION_DD_32]	; 得到显示位置

	mov ah, 0Fh		                ; 0000b: 黑底	1111b: 白字
	mov dl, al
	shr al, 4
	mov ecx, 2
.begin:
	and al, 01111b
	cmp al, 9
	ja	.1
	add al, '0'
	jmp	.2
.1:
	sub al, 10
	add al, 'A'
.2:
	mov [gs:edi], ax
	add edi, 2

	mov al, dl
	loop .begin

	mov [DISP_POSITION_DD_32], edi	; 显示完毕后，设置新的显示位置

  pop eax
	pop edi
	pop edx
	pop ecx

	ret
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   显示一个整形数
; ----------------------------------------------------------------------------------------------------------------------
print_int:
    mov	ah, 0Fh			            ; 0000b: 黑底    1111b: 白字
    mov	al, '0'
    push	edi
    mov	edi, [DISP_POSITION_DD_32]
    mov	[gs:edi], ax
    add edi, 2
    mov	al, 'x'
    mov	[gs:edi], ax
    add	edi, 2
    mov	[DISP_POSITION_DD_32], edi	; 显示完毕后，设置新的显示位置
    pop edi

	mov	eax, [esp + 4]
	shr	eax, 24
	call	print_al

	mov	eax, [esp + 4]
	shr	eax, 16
	call	print_al

	mov	eax, [esp + 4]
	shr	eax, 8
	call	print_al

	mov	eax, [esp + 4]
	call	print_al

	ret
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   内存拷贝，仿C语言mem_copy
; 函数原型：
;   void *mem_copy(void *es:dest, void *ds:src, int size)
; 默认是段内调用的
; 参数：
;   dest    目的地地址
;   src     源数据地址
;   size    要拷贝的数据量
; 返回值：
;   拷贝完成后的新数据的地址
; ----------------------------------------------------------------------------------------------------------------------
mem_copy:
    push esi
    push edi
    push ecx
; ----------------------------------------------------------------------------------------------------------------------
; 为什么是 +4*4->dest +4*5->src +4*6->size？
; C语言中，函数调用约定是，首先压入参数列表中的最后一个。即           栈
;   push size   ; int 4字节，32位                          esp | ecx |
;   push *src   ; 32位机，指针4字节，32位                        | edi |
;   push *dest  ; 32位机，指针4字节，32位                        | esi |
;   push eip    ; 4字节，32位，这里认为是段内调用的，不保存eds      | eip |
;   push esi    ; 4字节，32位                                  |*dest|
;   push edi    ；4字节，32位                                  | *src |
;   push ecx    ；4字节，32位                                  | size |
; ----------------------------------------------------------------------------------------------------------------------
    mov edi, [esp + 4 * 4]      ; edi = dest
    mov esi, [esp + 4 * 5]      ; esi = src
    mov ecx, [esp + 4 * 6]      ; ecx = size
.copy:
    cmp ecx, 0
    jz .copy_end                ; eax == 0，拷贝结束
    ; eax != 0，继续拷贝下一个字节
    mov al, [ds:esi]            ; 拷贝一字节给al
    inc esi                     ; esi++，指向下一个要拷贝的字节
    mov [es:edi], al            ; 拷贝al字节给目的地
    inc edi

    loop .copy                  ; 循环拷贝，直至ecx == 0
.copy_end:
    mov eax, [esp + 4 * 4]      ; 设置返回值

    pop ecx
    pop edi
    pop esi
    ret
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   初始化内核
; 将 KERNEL.BIN 的内容经过调整对齐之后放到内核挂载点处
; 我们通过遍历 Program Header，根据 Program Header 中的信息来确定把什么放入内存，放到什么位置，以及要放多少
; ----------------------------------------------------------------------------------------------------------------------
init_kernel_file:
    xor esi, esi
    xor ecx, ecx
    mov cx, word [KERNEL_PHY_ADDR + 44]     ; cx = e_phnum(Program Header的数量)
    mov esi, [KERNEL_PHY_ADDR + 28]         ; esi = e_phoff(Program header table在文件中的偏移)
    add esi, KERNEL_PHY_ADDR                ; ds:esi -> 第一个 Program header
.begin:
    mov eax, [esi + 0]                      ; eax -> p_type(段类型)
    cmp eax, 0
    jz .no_action                           ; p_type == 0，是一个不可用的段
    ; p_type != 0，是一个可用的段
; ----------------------------------------------------------------------------------------------------------------------
; 把elf格式的kernel.bin文件中指令拷贝到文件中已设定的虚拟地址0x1000处，即KERNEL_ENTRY_POINT_PHY_ADDR
; ----------------------------------------------------------------------------------------------------------------------
    push dword [esi + 16]                   ; 压入p_filesz（段在文件中的长度），作为mem_copy的最后一个参数size
    mov eax, [esi + 4]                      ; eax = p_offset，段的第一个字节在文件中的偏移
    add eax, KERNEL_PHY_ADDR                ; eax -> 段第一个字节
    push eax                                ; 压入段第一个字节的地址，作为mem_copy的src参数
    push dword [esi + 8]                    ; 压入p_vaddr（段的第一个字节在内存中的虚拟地址），作为mem_copy的dest参数
    call mem_copy                           ; 开始拷贝
    add esp, 4 * 3                          ; 清理堆栈
.no_action:
    add esi, 32                             ; esi += Program header结构大小
    dec ecx
    cmp ecx, 0
    jnz .begin                              ; 继续看下一个Program header

    ret
; ======================================================================================================================