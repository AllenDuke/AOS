; 在从引导程序跳转到加载程序后，cs为0x9000，ip为0x0100，即加载程序是要被加载到0x90100处的，而cs为0x9000
; 所以下面在计算标号地址时，应该加上0x0100的偏移量
org 0x100


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   一些宏定义，汇编伪指令不会产生机器代码
; ----------------------------------------------------------------------------------------------------------------------
STACK_BASE      equ     0x100       ; 用0x90000以下的地方来作为栈，要注意不要溢出
MESSAGE_LENGTH  equ 	10          ; 为简化代码, 下面每个要打印的字符串的长度均为 MESSAGE_LENGTH
; ======================================================================================================================


    jmp start


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   头文件
; ----------------------------------------------------------------------------------------------------------------------
%include "load.inc"         ; 挂载点相关的信息
%include "fat12hdr.inc"     ; 导入它是因为需要这些信息来加载内核文件
%include "pm.inc"           ; 保护模式的一些信息，各种宏和变量
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   GDT全局描述符表相关信息以及堆栈信息
; ----------------------------------------------------------------------------------------------------------------------
; 描述符                        基地址        段界限       段属性
GDT			        Descriptor	0,          0,          0							; 空描述符，必须存在，不然CPU无法识别GDT
CODE_SEG_DESC       Descriptor	0,          0xfffff,    DA_32 | DA_CR | DA_LIMIT_4K	; 0~4G，32位可读代码段，粒度为4KB
DATA_SEG_DESC       Descriptor  0,          0xfffff,    DA_32 | DA_DRW | DA_LIMIT_4K; 0~4G，32位可读写数据段，粒度为4KB
VIDEO_SEG_DESC      Descriptor  0xb8000,    0xfffff,    DA_DRW | DA_DPL3            ; 视频段，特权级3（用户特权级）

; GDT全局描述符表
GDT_LENGTH              equ     $ - GDT                             ; GDT的长度
gdtPtr                  dw      GDT_LENGTH - 1                      ; GDT指针.段界限，即地址的上界
                        dd      LOADER_PHY_ADDR + GDT               ; GDT指针.基地址
; GDT选择子
CODE_SEG_SELECTOR       equ     CODE_SEG_DESC - GDT                 ; 代码段选择子
DATA_SEG_SELECTOR       equ     DATA_SEG_DESC - GDT                 ; 数据段选择子
VIDEO_SEG_SELECTOR      equ     VIDEO_SEG_DESC - GDT | SA_RPL3      ; 视频段选择子，特权级3（用户特权级）
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   16位实模式代码段
; ----------------------------------------------------------------------------------------------------------------------
start:
    ; 寄存器复位
    mov	ax, cs              ; 此时的cs为LOADER_SERG，即0x9000，ip为0x0100
    mov	ds, ax
    mov	es, ax
    mov	ss, ax
    mov	sp, STACK_BASE      ; sp指向当前栈顶，栈向低地址生长

    ; 显示字符串 "Loading..."
    mov	dh, 0
    call print_string       ; 显示字符串

   ; 得到内存数
    mov ebx, 0              ; ebx = 后续值，开始时需为0
    mov di, memChkBuf16     ; es:di 指向一个地址范围描述符结构(Address Range Descriptor Structure)
check_mem:
	mov eax, 0E820h		    ; eax = 0000E820h
	mov ecx, 20			    ; ecx = 地址范围描述符结构的大小
	mov edx, 0534D4150h	    ; edx = 'SMAP'
	int 15h
	jc check_mem_fail		    ; 如果产生的进位，即CF = 1，跳转到.check_mem_fail
	add di, 20
	inc dword [mcrCountDD16]	; mcrCountDD16 = ARDS　的个数
	cmp ebx, 0
	jne check_mem		        ; ebx != 0，继续进行循环
	jmp check_mem_ok		    ; ebx == 0，得到内存数OK
check_mem_fail:
	mov dword [mcrCountDD16], 0
check_mem_ok:
    ; 操作软盘前，现将软驱复位
    xor ah, ah              ; xor:异或，ah = 0
    xor dl, dl              ; dl = 0
    int 0x13
    ; 接下来我们在软盘A中开始寻找文件
    mov word [sectorW], SECTOR_NUM_OF_ROOT_DIR     ; 读取软盘的根目录扇区号
; ----------------------------------------------------------------------------------------------------------------------
; 注意，KERNEL_SEG为0x7000，KERNEL_OFFSET为0。
; 现在要遍历根目录寻找kernel.bin，KERNEL_SEG:KERNEL_OFFSET将作为读取到的扇区内容的临时存放点和kernel.bin的存放点
; ----------------------------------------------------------------------------------------------------------------------
search_file_in_root_dir_begin:
    cmp word [rootDirSizeLoopW], 0
    jz no_file                  ; 读完了整个根目录扇区都没找到，所以没有
    dec word [rootDirSizeLoopW] ; wRootDirSizeLoop--
    ; 读取扇区
    mov ax, KERNEL_SEG          ; es = KERNEL_SEG
    mov es, ax
    mov bx, KERNEL_OFFSET
    mov ax, [sectorW]
    mov cl, 1
    call read_sector

    mov si, kernelFileName      ; ds:si -> Loader的文件名称
    mov di, KERNEL_OFFSET       ; es:di -> KERNEL_SEG:KERNEL_OFFSET -> 加载到内存中的扇区数据
    cld                         ; 字符串比较方向，si、di方向向右

    ; 开始在扇区中寻找文件，比较文件名
    mov dx, 16                  ; 一个扇区512字节，FAT目录项占用32个字节，512/32 = 16，所以一个扇区有16个目录项
search_for_file:
    cmp dx, 0
    jz next_sector_in_root_dir  ; 读完整个扇区，依旧没找到，准备加载下一个扇区
    dec dx                      ; dx--
    ; 应该开始比较目录项中的文件名了
    mov cx, 11
cmp_file_name:
    cmp cx, 0
    jz file_name_found          ; cx = 0，整个文件名里的字符都匹配上了，我们发现它了
    dec cx                      ; cx--
    lodsb                       ; ds:si -> al, si++
    cmp al, byte [es:di]        ; 比较字符
    je go_on                    ; 字符相同，准备继续比较下一个
    jmp different               ; 只要有一个字符不相同，就表明本目录项不是我们要寻找的文件的目录项
go_on:
    inc di
    jmp  cmp_file_name
different:
    and di, 0xfff0              ; di &= f0, 11111111 11110000，是为了让它指向本目录项条目的开始。
    add di, 32                  ; di += 32， 让di指向下一个目录项
    mov si, kernelFileName
    jmp search_for_file         ; 重新开始在下一个目录项中查找文件并比较
next_sector_in_root_dir:
    add word [sectorW], 1       ; 准备开始读取下一个扇区
    jmp search_file_in_root_dir_begin
no_file:
    mov dh, 4
    call print_string           ; 打印"NO KERNEL!"
    ; 死循环
    jmp $
file_name_found:
    ; 准备参数，开始读取文件数据扇区
    mov ax, ROOT_DIR_SECTORS    ; ax = 根目录占用空间（占用的扇区数）
    and di, 0xfff0              ; di &= f0, 11111111 11110000，是为了让它指向本目录项条目的开始。
    push eax                    ; 保存eax的值
    mov eax, [es:di + 0x1c]     ; FAT目录项第0x1c处偏移是文件大小
    mov dword [kernelSizeDW], eax   ; 保存内核文件大小
    cmp eax, KERNEL_KEEP_SPACE  ; 看看内核文件大小有没有超过我们为其保留的大小
    ja kernel_file_too_large    ; 超过了！
    pop eax                     ; 恢复eax
    jmp start_to_load_file      ; 没超过，准备开始加载内核文件
kernel_file_too_large:          ; 内核文件太大了，超过了我们给它留的128KB
    mov dh, 3
    call print_string           ; 打印"Too Large!"
    jmp $                       ;
start_to_load_file:
    add di, 0x1a                ; FAT目录项第0x1a处偏移是文件数据所在的第一个簇号
    mov cx, word [es:di]        ; cx = 文件数据所在的第一个簇号
    push cx                     ; 保存文件数据所在的第一个簇号
    ; 通过簇号计算它的真正扇区号
    add cx, ax
    add cx, DELTA_SECTOR_NUM    ; 簇号 + 根目录占用空间 + 文件开始扇区号 == 文件数据的第一个扇区
    ; 内核程序将被加载至KERNEL_SEG:KERNEL_OFFSET处，即0x7000:0x0000处。
    mov ax, KERNEL_SEG
    mov es, ax                  ; es <- KERNEL_SEG
    mov bx, KERNEL_OFFSET       ; bx <- KERNEL_OFFSET
    mov ax, cx                  ; ax = 文件数据的第一个扇区
loading_file:
    ; 我们每读取一个数据扇区，就在“Loading...”之后接着打印一个点，形成一种动态加载的动画。
    ; 0x10中断，0xe功能 --> 在光标后打印一个字符
    push ax
    push bx
    mov ah, 0xe
    mov al, '.'
    mov bl, 0xf
    int 0x10
    pop bx
    pop ax

    mov cl, 1                   ; 读1个
    call read_sector            ; 读取
    pop ax                      ; 取出前面保存的文件的的簇号
    call get_fat_entry          ; 通过簇号获得该文件的下一个FAT项的值
    cmp ax, 0xff8
    jae file_loaded             ; 加载完成...
    ; FAT项的值 < 0xff8，那么我们继续设置下一次要读取的扇区的参数
    ; 通过簇号计算它的真正扇区号
    push ax                     ; 保存簇号
    mov dx, ROOT_DIR_SECTORS
    add ax, dx
    add ax, DELTA_SECTOR_NUM    ; 簇号 + 根目录占用空间 + 文件开始扇区号 == 文件数据的扇区
    add bx, [bpbBytsPerSec]     ; bx += 扇区字节量
; ----------------------------------------------------------------------------------------------------------------------
; 注意，在刚开始加载内核程序时，16位寄存器bx的值为0，可达的最大值0xffff，如果产生了一个进位，意味者此时已被加载的内核达到了64KB。
; bx又重新为0，所以要让es+=0x1000，指向下一64KB开始的地方。
; ----------------------------------------------------------------------------------------------------------------------
    jc kernel_great_64KB        ; 如果bx += 扇区字节量，产生了一个进位，说明已经读满64KB，内核文件大于64KB
    jmp keep_loading            ; 内核文件还在64KB内，继续正常加载
kernel_great_64KB:
    ; es += 0x1000，es指向下一个段，准备继续加载
    push ax
    mov ax, es
    add ax, 0x1000
    mov es, ax
    pop ax
keep_loading:                   ; 继续加载内核文件
    jmp loading_file
file_loaded:
    call kill_motor             ; 关闭软驱马达
    mov dh, 1
    call print_string           ; 打印"KERNEL OK!"
; ----------------------------------------------------------------------------------------------------------------------
; 准备进入32位保护模式
; ----------------------------------------------------------------------------------------------------------------------
    ; 1 首先，进入保护模式必须有 GDT 全局描述符表，我们将gdtPtr加载到48位寄存器 gdtr
    lgdt	[gdtPtr]

    ; 2 由于保护模式中断处理的方式和实模式不一样，所以我们需要先关闭中断，否则会引发错误
    cli

    ; 3 打开地址线A20，不打开也可以进入保护模式，但内存寻址能力受限（1MB）
    in al, 92h
    or al, 00000010b
    out 92h, al

    ; 4 进入16位保护模式，设置cr0的第0位：PE（保护模式标志）为1
    mov eax, cr0
    or 	eax, 1
    mov cr0, eax

; ----------------------------------------------------------------------------------------------------------------------
; 注意，我们并没有去设置GDT中代码段描述符的32位段基地址，它仍然是0，但是我们可以利用偏移量来进入32保护模式，去执行pm32_start处的代码。
; 这里在补充一下32位保护模式下的内存寻址的计算方式。
; 此时，下一条指令地址是这样计算的，cs存着的是段选择子，gdtr存着的是gdt的线性基地址和界限，cpu可以通过此二者来访问到gdt的某一项，
; 然后取出该项中的段线性基地址，最后加上ip中的偏移量，这样就可以得知下一条指令的物理地址了。
; ----------------------------------------------------------------------------------------------------------------------

    ; 5 真正进32位入保护模式！前面的4步已经进入了保护模式
    ; 	现在只需要跳入到一个32位代码段就可以真正进入32位保护模式了！
    jmp dword CODE_SEG_SELECTOR:LOADER_PHY_ADDR + pm32_start

    ; 如果上面一切顺利，这一行永远不可能执行的到
    jmp $

; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   一些变量 ; db 汇编伪指令，表示其后的每个操作数占1字节。dw，2字节。dd，double word 4字节。
; ----------------------------------------------------------------------------------------------------------------------
rootDirSizeLoopW    dw      ROOT_DIR_SECTORS    ; 根目录占用的扇区数14，在循环中将被被逐步递减至0
sectorW             dw      0                   ; 要读取的扇区号
isOdd               db      0                   ; 读取的FAT条目是不是奇数项?
kernelSizeDW        dd      0                   ; 内核文件的大小
; ----------------------------------------------------------------------------------------------------------------------
; 要显示的字符串
; ----------------------------------------------------------------------------------------------------------------------
kernelFileName		db  "KERNEL  BIN", 0	; KERNEL.BIN 之文件名

loaderMessage 		db	"Loading..."        ; 10, 不够则用空格补齐. 序号 0
                    db  "KERNEL OK!"        ; 序号1
                    db  "MemChkFail"        ; 序号2
                    db  "Too large!"        ; 序号3
                    db  "NO KERNEL!"        ; 序号4
                    db  "BreakPoint"        ; 序号5
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   16位支持函数库
; ----------------------------------------------------------------------------------------------------------------------
%include "loader_16lib.asm"
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   32位代码段
; ----------------------------------------------------------------------------------------------------------------------
section code32 align=32     ; 该段的开始地址会32字节对齐，编译时会寻找最近的对齐地址
bits 32                     ; 指示编译器产生在32位模式下工作的代码，默认16位模式。
; ----------------------------------------------------------------------------------------------------------------------
; 关于段开始地址，NASM默认会有一个段，默认4字节对齐，使用align来改变默认值。
;
; 关于段中指令编译模式，默认16模式，使用bits来改变默认值，会用0x66指令前缀来区分。
; 例如mov ax, 0x1234，对应16位模式二进制指令：B83412，对应32位模式二进制指令：66B83412。（从左往右，地址由低到高，小端，低地址存低位），
; 指令mov eax, 0x5678，对应16位模式二进制指令：66B878560000，对应32位模式二进制指令：B878560000
; ----------------------------------------------------------------------------------------------------------------------
pm32_start:                 ; 跳转到这里，说明已经进入32位保护模式
    mov ax, DATA_SEG_SELECTOR
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov ss, ax              ; ds = es = fs = ss = 数据段
    mov esp, STACK_TOP      ; 设置栈顶
    mov ax, VIDEO_SEG_SELECTOR
    mov gs, ax              ; gs = 视频段

    ; 计算内存大小
    call cal_mem_size
    ; 打印内存信息
    call print_mem_size
    ; 启动分页机制
    call setup_paging
    ; 初始化内核程序
    call init_kernel_file

    ; 进入内核前，我们别忘了将一些重要的参数保存，以便以后内核可以很方便的获取它们
    mov dword [BOOT_PARAM_ADDR], BOOT_PARAM_MAGIC   ; AOS引导参数的魔数
    mov eax, [memSizeDD16]                          ; 内存大小
    mov [BOOT_PARAM_ADDR + 4], eax                  ; 第一个引导参数：内存大小
    mov eax, KERNEL_PHY_ADDR
    add eax, KERNEL_OFFSET                          ; 内核文件的物理地址 = KERNEL_SEG * 16 + KERNEL_OFFSET
    mov [BOOT_PARAM_ADDR + 8], eax                  ; 第二个引导参数：内核文件所在物理地址
    ; 暂时我只想到这两个参数需要保存，以后有更多参数可以直接追加保存在后面，我们保留给引导参数的内存还挺大的！

    ; 正式跳入内核，Loader将CPU控制权转交给内核，至此，Loader的使命也结束了！比Boot厉害吧！
    ; 从这里的函数运行成功后，我们才真正算是进入编写操作系统的门槛！
    jmp CODE_SEG_SELECTOR:KERNEL_ENTRY_POINT_PHY_ADDR

    ; 永远到达不了的真实
    jmp $
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   32位支持函数库
; ----------------------------------------------------------------------------------------------------------------------
%include "loader_32lib.asm"
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
;   32位数据段
; ----------------------------------------------------------------------------------------------------------------------
section data32 align=32     ; 32字节对齐
DATA32:
; ----------------------------------------------------------------------------------------------------------------------
; 16位实模式下使用的数据地址，变量以16做后缀与32位下的变量区分开。
; ----------------------------------------------------------------------------------------------------------------------
; 字符串
strMemSize16         db "Memory Size: ", 0
strKB16              db "KB", 10, 0
strsetup_paging16    db "Setup paging.", 10, 0
strDebug16           db "BreakPoint", 10,0

; 变量
mcrCountDD16         dd 0        ; 检查完成的ARDS的数量，为0则代表检查失败
memSizeDD16          dd 0        ; 内存大小
dispPositionDD16     dd (80 * 4 + 0) * 2 ; 初始化显示位置为第 4 行第 0 列

; 地址范围描述符结构(Address Range Descriptor Structure)，20字节
ARDS16:
    baseAddrLowDD16  dd 0        ; 基地址低32位
    baseAddrHighDD16 dd 0        ; 基地址高32位
    lengthLowDD16    dd 0        ; 内存长度（字节）低32位
    lengthHighDD16   dd 0        ; 内存长度（字节）高32位
    typeDD16         dd 0        ; ARDS的类型，用于判断是否可以被OS使用

; 内存检查结果缓冲区，用于存放没存检查的ARDS结构，256字节是为了对齐32位，256/20=12.8，所以这个缓冲区可以存放12个ARDS。
memChkBuf16          times 256 db 0

; ----------------------------------------------------------------------------------------------------------------------
; 32位保护模式下的数据地址符号
; ----------------------------------------------------------------------------------------------------------------------
STR_MEM_SIZE_32             equ LOADER_PHY_ADDR + strMemSize16
STR_KB_32                   equ LOADER_PHY_ADDR + strKB16
STR_SETUP_PAGING_32         equ LOADER_PHY_ADDR + strsetup_paging16

MCR_COUNT_DD_32             equ LOADER_PHY_ADDR + mcrCountDD16
MEM_SIZE_DD_32              equ LOADER_PHY_ADDR + memSizeDD16
DISP_POSITION_DD_32         equ LOADER_PHY_ADDR + dispPositionDD16

ARDS_32                     equ LOADER_PHY_ADDR + ARDS16
    BASE_ADDR_LOW_DD_32     equ LOADER_PHY_ADDR + baseAddrLowDD16
    BASE_ADDR_HIGH_DD_32    equ LOADER_PHY_ADDR + baseAddrHighDD16
    LENGTH_LOW_DD_32        equ LOADER_PHY_ADDR + lengthLowDD16
    LENGTH_HIGH_DD_32       equ LOADER_PHY_ADDR + lengthHighDD16
    TYPE_DD_32              equ LOADER_PHY_ADDR + typeDD16

MEM_CHK_BUF_32              equ LOADER_PHY_ADDR + memChkBuf16

; 堆栈就在数据段的末尾，一共给这个32位代码段堆栈分配4KB
stackSpace                  times 0x1000    db 0
STACK_TOP                   equ LOADER_PHY_ADDR + $     ; 栈顶
; ======================================================================================================================
