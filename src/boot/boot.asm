; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
; 一些说明
; ----------------------------------------------------------------------------------------------------------------------
; 加电启动后，一旦BIOS发现了一个正确的引导扇区(以0xAA55结尾)，它就会将这个引导扇区的512B的内容加载到内存0x7c00处，这是由硬件决定的。
; 然后就跳转到内存0000:0x7c00处开始执行其上的指令。
;
; 函数名统一使用大写和下划线，使用动词+名词，或者动词的形式命名，例如，PRINT_STRING，意为字符串打印函数。使用 : 且换行。
; 保险起见，在函数内，会先将使用到的寄存器的值，返回前，恢复寄存器到函数调用前状态。
;
; 宏定义统一使用大驼峰命名法，例如，StackBase，意为栈基地址。不使用 ：且不换行。
;
; 变量名统一使用小驼峰命名法，例如，isOdd，意为是否奇数。不使用 : 且不换行。
; ======================================================================================================================


; 值得注意的时，即使没有这个org汇编伪指令，往后的这些内容都将会被加载到内存0000:0x7c00处
; 汇编伪指令，表示往后需要计算 label 的绝对地址时，还再要加上0x7c00的偏移量。
; 如果不涉及 label的计算，那么是不需要这个指令的
org 0x7c00


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
; 一些宏定义
; ----------------------------------------------------------------------------------------------------------------------
LoaderSeg       equ 0x9000      ; LOADER加载到的段地址，不能往上越过0x9fc00
LoaderOffset    equ 0x100       ; LOADER加载到的偏移地址，预留一定的边界，即LOADER加载到0x90100

StackBase       equ 0x7c00      ; 用0x7c00以下的地方来作为栈，要注意不要达到0x0500
MessageLength	equ	10          ; 为简化代码, 下面每个字符串的长度均为 MessageLength
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
; 一些变量
; ----------------------------------------------------------------------------------------------------------------------
wRootDirSizeLoop    dw      RootDirSectors  ; 根目录占用的扇区数14，在循环中将被被逐步递减至0
wSector             dw      0               ; 要读取的扇区号
isOdd               db      0               ; 读取的FAT条目是不是奇数项?
; ======================================================================================================================


    jmp BEGIN   ; 直接跳转指令
    nop         ; 空指令
    ; 引导扇区的格式之一

    ; 导入FAT12头以及相关常量信息
    %include "fat12hdr.inc"


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
; 引导程序
; ----------------------------------------------------------------------------------------------------------------------
BEGIN:
    ; 寄存器复位
    mov ax, cs
    mov ds, ax
    mov ss, ax
    ; 此时代码段、数据段、堆栈段地址都是一样的，0
    mov sp, StackBase   ; sp指向当前栈顶，栈向低地址生长

    ; 清理屏幕
    call CLEAR          ; 相当于将ip压栈，然后改变ip。

    ; 显示字符串 "Booting..."
    mov	dh, 0			; "Booting..."
    call STRING_PRINT	; 显示字符串

    ; 操作软盘前，现将软驱复位
    xor ah, ah          ; xor:异或，ah = 0，听说比mov ah, 0更快
    xor dl, dl          ; dl = 0，dl为驱动器号，0为软盘
    int 0x13

    ; 设定变量，接下来我们在软盘A中开始寻找文件"load.bin"，从根目录开始寻找它的所在位置。
    mov word [wSector], SectorNoOfRootDirectory     ; 直接寻址方式，ds+wSector
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
; 扇区号从0开始，根目录从第19扇区开始，共占据14个扇区。现在遍历根目录寻找文件load.bin，
; 找到后，将load.bin加载到LoaderSeg:LoaderOffset
; ----------------------------------------------------------------------------------------------------------------------
SEARCH_FILE_IN_ROOR_DIR_BEGIN:
    cmp word [wRootDirSizeLoop], 0
    jz NO_FILE                          ; 读完了整个根目录扇区都没找到，所以没有
    dec word [wRootDirSizeLoop]         ; wRootDirSizeLoop--

    ; 读取扇区
    mov ax, LoaderSeg
    mov es, ax                          ; es = LOADER_SEG
    mov bx, LoaderOffset
    mov ax, [wSector]
    mov cl, 1
    call READ_SECTOR                    ; 从第 ax 个 Sector 开始, 将 cl 个 Sector 读入 es:bx 中

    mov si, loaderFileName              ; ds:si -> loader的文件名称
    mov di, LoaderOffset                ; es:di -> LoaderSeg:LoaderOffset -> 加载到内存中的扇区数据
    cld                                 ; 字符串比较方向，si、di方向向右

    ; 开始在扇区中寻找文件，比较文件名
    mov dx, 16                          ; 一个扇区512字节，FAT目录项占用32个字节，512/32 = 16，所以一个扇区有16个目录项
SEARCH_FOR_FILE:
    cmp dx, 0
    jz NEXT_SECTOR_IN_ROOT_DIR          ; 读完整个扇区，依旧没找到，准备加载下一个扇区
    dec dx                              ; dx--

    mov cx, 11                          ; 开始比较目录项中的11字节的文件名了
CMP_FILENAME:
    cmp cx, 0
    jz FILENAME_FOUND                   ; cx = 0，整个文件名里的字符都匹配上了，我们发现它了
    dec cx                              ; cx--
    lodsb                               ; ds:si -> al, si++
    cmp al, byte [es:di]                ; 比较字符
    je GO_ON                            ; 字符相同，准备继续比较下一个
    jmp DIFFERENT                       ; 只要有一个字符不相同，就表明本目录项不是我们要寻找的文件的目录项

GO_ON:
    inc di
    jmp  CMP_FILENAME
DIFFERENT:
    and di, 0xfff0                      ; di &= f0, 11111111 11110000，是为了让它指向本目录项条目的开始。

    add di, 32                          ; di += 32， 让di指向下一个目录项
    mov si, loaderFileName
    jmp SEARCH_FOR_FILE                 ; 重新开始在下一个目录项中查找文件并比较

NEXT_SECTOR_IN_ROOT_DIR:
    add word [wSector], 1               ; 准备开始读取下一个扇区
    jmp SEARCH_FILE_IN_ROOR_DIR_BEGIN

NO_FILE:
    mov dh, 2
    call DispStr                        ; 打印"NO LOADER!"
    jmp $                               ; 死循环

FILENAME_FOUND:
    ; 准备参数，开始读取文件数据扇区
    mov ax, RootDirSectors              ; ax = 根目录占用空间（占用的扇区数）
    and di, 0xfff0                      ; di &= f0, 11111111 11110000，是为了让它指向本目录项条目的开始。
    add di, 0x1a                        ; FAT目录项第0x1a处偏移是文件数据所在的第一个簇号
    mov cx, word [es:di]                ; cx = 文件数据所在的第一个簇号
    push cx                             ; 保存文件数据所在的第一个簇号
    ; 通过簇号计算它的真正扇区号
    add cx, ax
    add cx, DeltaSectorNo               ; 簇号 + 根目录占用空间 + 文件开始扇区号 == 文件数据的第一个扇区
    mov ax, LoaderSeg
    mov es, ax                          ; es <- LoaderSeg
    mov bx, LoaderOffset                ; bx <- LoaderOffset
    mov ax, cx                          ; ax = 文件数据的第一个扇区
; ----------------------------------------------------------------------------------------------------------------------
; load.bin的数据将从 LoaderSeg:LoaderOffset 一直往上叠加。
; ----------------------------------------------------------------------------------------------------------------------
LOADING_FILE:
    ; 我们每读取一个数据扇区，就在“Loading...”之后接着打印一个点，形成一种动态加载的动画。
    ; 0x10中断，0xe功能 --> 在光标后打印一个字符
    push ax
    push bx
    mov ah, 0xe
    mov al, '.'
    mov bl, 0xf
    int 0x10
    pop bx
    pop ax

    mov cl, 1                           ; 读1个
    call ReadSector                     ; 读取
    pop ax                              ; 取出前面保存的文件的的簇号
    call GET_FATEntry                   ; 通过簇号获得该文件的下一个FAT项的值
    cmp ax, 0xff8
    jae FILE_LOADED                     ; 加载完成...
    ; FAT项的值 < 0xff8，那么我们继续设置下一次要读取的扇区的参数
    ; 通过簇号计算它的真正扇区号
    push ax                             ; 保存簇号
    mov dx, RootDirSectors
    add ax, dx
    add ax, DeltaSectorNo               ; 簇号 + 根目录占用空间 + 文件开始扇区号 == 文件数据的扇区
    add bx, [bpbBytsPerSec]             ; bx += 扇区字节量，数据读到 es:bx
    jmp LOADING_FILE
FILE_LOADED:
    mov dh, 1
    call DispStr                        ; 打印"Loaded ^-^"

    jmp LOADER_SEG:LOADER_OFFSET        ; 跳转到Loader程序，至此我们的引导程序使命结束

; ======================================================================================================================

; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
; 函数名: READ_SECTOR
; 作用: 从第 ax 个 Sector 开始, 将 cl 个 Sector 读入 es:bx 中
; 1.44MB的软盘的组成：2*80*18*512
;   1. 0 1 两个磁头
;   2. 每面 80 磁道
;   3. 每磁道 18 扇区
;   4. 每扇区 512 字节
; 所有扇区由0开始编号，即0~159，那么组成为(柱面号，磁头号，所处磁道扇区号)
; 设扇区号为 x
;                          ┌ 柱面号 = y >> 1
;       x           ┌ 商 y ┤
; -------------- => ┤      └ 磁头号 = y & 1
;  每磁道扇区数      │
;                   └ 余 z => 起始扇区号 = z + 1，实际上在硬件的编码中，是从1起的。
; ----------------------------------------------------------------------------------------------------------------------
READ_SECTOR:
	push	bp
	mov	bp, sp
	sub	esp, 2			    ; 辟出两个字节的堆栈区域保存要读的扇区数: byte [bp-2]

	mov	byte [bp-2], cl     ; 基址变址寻址，ss+bp-2
	push	bx			    ; 保存 bx
	mov	bl, [bpbSecPerTrk]	; bl: 除数，bpbSecPerTrk：每磁道扇区数，直接寻址，ds+bpbSecPerTrk，bl=18

	; 除法指令，ax为被除数，商为y，余数为z
	div	bl		       	    ; y 在 al 中, z 在 ah 中
	inc	ah			        ; z ++
	mov	cl, ah			    ; cl <- 起始扇区号
	mov	dh, al			    ; dh <- y
	shr	al, 1			    ; y >> 1 (其实是 y/BPB_NumHeads, 这里BPB_NumHeads=2)
	mov	ch, al			    ; ch <- 柱面号
	and	dh, 1			    ; dh & 1 = 磁头号
	pop	bx			        ; 恢复 bx
	; 至此, "柱面号，磁头号，所处磁道扇区号" 全部得到 ^^^^^^^^^^^^^^^^^^^^^^^^
	mov	dl, [bsDrvNum]		; 驱动器号 (0 表示 A 盘)

G0_ON_READING:
	mov	ah, 2				; 读
	mov	al, byte [bp-2]		; 读 al 个扇区
	int	13h                 ; 13h中断读磁盘
	jc	G0_ON_READING		; 如果读取错误 CF 会被置为 1, 这时就不停地读, 直到正确为止

	add	esp, 2
	pop	bp

	ret
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
; 作用：找到簇号为 ax 在 FAT 中的条目，然后将结果放入 ax 中。代入簇号2去分析。
; 注意：中间我们需要加载 FAT表的扇区到es:bx处，所以我们需要先保存es:bx。
; 要点是，找出簇号为 ax 所在的 FAT项 相对于 FAT表1 的字节偏移量，然后算出所在扇区 和 扇区内偏移量，将两个扇区读进内存，
; 最后能算出 该FAT项 的在内存的地址。这时要区分簇号是奇还是偶，将12位的值存到 ax 。
; ----------------------------------------------------------------------------------------------------------------------
GET_FATEntry:
    push es
    push bx

    ; 在加载的段地址处开辟出新的空间用于存放加载的FAT表
    push ax
    mov ax, LoaderSeg - 0x100
    mov es, ax
    pop ax

    ; 首先计算出簇号在FAT中的字节偏移量，然后还需要计算出该簇号的奇偶性、
    ; 偏移值: 簇号 * 3 / 2 的商，因为3个字节表示2个簇，所以字节和簇之间的比例就是3:2。
    mov byte [isOdd], 0     ; isOdd = FALSE
    mov bx, 3               ; bx = 3
    mul bx                  ; ax * 3 --> dx存放高16位，ax存放低16位
    mov bx, 2               ; bx = 2
    div bx                  ; dx:ax / 2 --> ax存放商，dx存放余数。
    cmp dx, 0
    je EVEN
    mov byte [isOdd], 1     ; isOdd = TRUE
; ----------------------------------------------------------------------------------------------------------------------
; 此时ax为该FAT项相对于FAT表1的字节偏移量
; ----------------------------------------------------------------------------------------------------------------------
EVEN:                       ; 偶数，意味者该FAT项的高4位在下一字节的低4位，反之意为着该FAT项的低4位在上一字节的高4位
    ; FAT表占 9个扇区 ， 字节偏移量 5 ， 5 / 512 -- 0 .. 5， FAT表中的0扇区， FAT表0扇区中这个簇号所在偏移是5
    ; 570   570 / 512 -- 1 .. 58， FAT表中的1扇区， FAT表1扇区中这个簇号所在偏移是58
    xor dx, dx              ; dx = 0
    mov bx, [bpbBytsPerSec] ; bx = 每扇区字节数
    div bx                  ; dx:ax / 每扇区字节数，ax(商)存放FAT项相对于FAT表中的扇区号，
                            ; dx(余数)FAT项在相对于FAT表中的扇区的偏移。
    push dx                 ; 保存FAT项在相对于FAT表中的扇区的偏移。
    mov bx, 0               ; bx = 0，es:bx --> (LoaderSeg - 0x100):0

    ; 其实编码上会有点奇怪的，因为有些认为是需要计算的，有些认为它一般是一个固定值，比如这里认为它位于第一个FAT表中
    add ax, SectorNoOfFAT1  ; 此句执行之后的 ax 就是 FATEntry 所在的扇区号，即加上FAT项的整体偏移量
    mov cl, 2               ; 读取两个扇区
    call ReadSector         ; 一次读两个，避免发生边界错误问题，因为一个FAT项可能会跨越两个扇区
    pop dx                  ; 恢复FAT项在相对于FAT表中的扇区的偏移。
; ----------------------------------------------------------------------------------------------------------------------
; 此时dx为该FAT项所在扇区的字节偏移量，而扇区已被读取到内存es:bx处。
;        LoaderSeg          |————|
;        LoadererSeg-100h   |————| es:bx，该FAT项所在的中两个扇区内容
;                           |    |
; ----------------------------------------------------------------------------------------------------------------------
    ; todo 这里的bx=0，应该可以换成 mov bx, dx
    add bx, dx              ; bx += FAT项在相对于FAT表中的扇区的偏移，得到FAT项在内存中的偏移地址，因为已经将扇区读取到内存中
    mov ax, [es:bx]         ; ax = 簇号对应的FAT项，但还没完成，读了两个字节
    cmp byte [isOdd], 1
    jne EVEN_2
    ; 奇数FAT项处理
    shr ax, 4               ; 需要将低四位清零（他是上一个FAT项的高四位）
    jmp GET_FATEntry_OK
EVEN_2:                     ; 偶数FAT项处理
    and ax, 0x0fff           ; 需要将高四位清零（它是下一个FAT项的低四位）
GET_FATEntry_OK:
	pop bx
	pop es
    ret
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
; 清屏函数，清理BIOS的输出，通过call来调用，不可以用jmp
; ----------------------------------------------------------------------------------------------------------------------
CLEAR:
    ; ax bx cx dx 压栈
    push ax
    push bx
    push cx
    push dx

    ; 调用10号中断，清理输出
    mov	ax, 0x0600  ; AH = 6,  AL = 0h
    mov	bx, 0x0700  ; 黑底白字(BL = 07h)
    mov	cx, 0       ; 左上角: (0, 0)
    mov	dx, 0x0184f ; 右下角: (80, 50)
    int	0x10

    ; 恢复 dx cx bx ax
    pop dx
    pop cx
    pop bx
    pop ax

    ; 相当于恢复之前压栈的ip，返回原来的地方，接着执行原来的下一条指令
    ret
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
; 要显示的字符串
; db 汇编伪指令，表示其后的每个操作数占1字节。dw，2字节。dd，double word 4字节。
; ----------------------------------------------------------------------------------------------------------------------
loaderFileName		db	"LOADER  BIN", 0    ; LOADER.BIN 之文件名

; 启动时的一些信息
bootMessage 		db	"Booting..."        ; 12字节, 不够则用空格补齐. 序号 0
                    db  "Loaded ^-^"
                    db  "NO LOADER!"
; ======================================================================================================================


; ======================================================================================================================
; ----------------------------------------------------------------------------------------------------------------------
; 字符串显示函数
; 显示一个字符串, 函数开始时 dh 中应该是字符串序号(0-based)，即 dh=0 -> "Booting..." dh=1 -> "Loaded ^-^"，且dh为要打印的行
; ----------------------------------------------------------------------------------------------------------------------
PRINT_STRING:
    push ax
    push bp
    push ds
    push es
    push cx
    push bx
    push dx

	mov	ax, MessageLength
	mul	dh
	add	ax, BootMessage
	mov	bp, ax  ; ┓
	mov	ax, ds  ; ┣ ES:BP = 串地址
	mov	es, ax  ; ┛
	; es = ds, 但由于两个段寄存器间没有直接通路，所以不能使用mov指令，也就是说mov指令的两个操作数不能同时为段寄存器
    ; 所以要借助第三方中转，比如可以  mov ax,ds   mov es,ax

	mov	cx, MessageLength   ; CX = 串长度
	mov	ax, 1301h           ; AH = 13,  AL = 01h
	mov	bx, 0007h           ; 页号为0(BH = 0) 黑底白字(BL = 07h)
	mov	dl, 0               ; 要打印的位置 列
	int	10h

	pop dx
	pop bx
	pop cx
	pop es
	pop ds
	pop bp
	pop ax
	ret
; ======================================================================================================================


; $$为汇编伪指令，表示起始地址
times 510-($-$$) db 0   ; 意思是从当前到510，用0来填充
dw 0xaa55               ; 引导扇区的结束标记