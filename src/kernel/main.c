//
// Created by 杜科 on 2020/10/8.
//

#include "kernel.h"

int DISPLAY_POSITION = (80 * 6 + 0) * 2; /* 第6行，第0列 */

void low_print(char *str);

void aos_main(void) {
    low_print("aos_main\n");
    low_print("Hello World!\n");
    while (1) {}
}

/*=========================================================================*
 *				panic				   *
 *	内核遇到了不可恢复的异常或错误，立即准备宕机
 *=========================================================================*/
PUBLIC void panic(
        _CONST char* msg,        /* 错误消息 */
        int error_no            /* 错误代码 */
){
    /* 当flyanx发现无法继续运行下去的故障时将调用它。典型的如无法读取一个很关键的数据块、
     * 检测到内部状态不一致、或系统的一部分使用非法参数调用系统的另一部分等。
     * 这里对printf的调用实际上是调用printk,这样当正常的进程间通信无法使用时核心仍能够
     * 在控制台上输出信息。
     */

    /* 有错误消息的话，请先打印 */
    if(msg != NIL_PTR){
        printf("\n!***** Flyanx kernel panic: %s *****!\n", msg);
        if(error_no != NO_NUM)
            printf("!*****     error no: 0x%x     *****!", error_no);
        printf("\n");
    }
    /* 好了，可以宕机了 */
    level0(down_run);
}

/*=========================================================================*
 *				idle_task				   *
 *	            待机任务
 *=========================================================================*/
PUBLIC void idle_task(void) {
    /* 本例程是一个空循环，Flyanx 系统没有任何进程就绪时，则会调用本例程。
     * 本例程的循环体使用了 hlt 指令，使其 CPU 暂停工作并处于待机等待状态，
     * 不至于像传统的死循环一样，消耗大量的 CPU 资源。而且在每个待机的过程
     * 中都会保持中断开启，保证待机时间内随时可以响应活动。
     */
    while (TRUE)
        level0(halt);

}